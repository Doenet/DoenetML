use std::collections::HashMap;

use serde::Serialize;

use crate::{
    state::{StateVarMutableView, StateVarValue},
    ComponentIdx, StateVarIdx,
};

pub type EssentialStateVar = StateVarMutableView;

/// Description of essential data
/// - component_idx: which component generated it
/// - origin: what aspect of the component generated it
#[derive(Debug, Clone)]
pub struct EssentialStateDescription {
    pub component_idx: ComponentIdx,
    pub origin: EssentialDataOrigin,
}

/// Essential data can be generated by
/// - a state variable requesting it
/// - a string child, converted into essential data
///   so that it can change when requested
/// - a string in an attribute
#[derive(Serialize, Debug, Clone, Eq, Hash, PartialEq)]
pub enum EssentialDataOrigin {
    /// Essential data was generated because a state variable requested it.
    StateVar(StateVarIdx),

    /// Essential data was generated by a string child.
    ///
    /// Unnamed *usize* field is the index of the string child
    StringChild(usize),

    /// Essential data was generated by a string in an attribute.
    ///
    /// **TODO**: how does this work?
    Attribute(usize, &'static str, usize),
}

// TODO: presumably there are other variants given that we have an enum here
// If not, remove enum.
pub enum InitialEssentialData {
    Single {
        value: StateVarValue,
        used_default: bool,
    },
}

pub fn essential_data_exists_for(
    component_idx: ComponentIdx,
    origin: &EssentialDataOrigin,
    essential_data: &Vec<HashMap<EssentialDataOrigin, EssentialStateVar>>,
) -> bool {
    essential_data[component_idx].contains_key(origin)
}

/// Add essential data for a state variable or string child
pub fn create_essential_data_for(
    component_idx: ComponentIdx,
    origin: EssentialDataOrigin,
    initial_values: InitialEssentialData,
    essential_data: &mut Vec<HashMap<EssentialDataOrigin, EssentialStateVar>>,
) -> &EssentialStateVar {
    let comp_essential_data = &mut essential_data[component_idx];

    assert!(!comp_essential_data.contains_key(&origin));

    let essential_state = match initial_values {
        InitialEssentialData::Single {
            value,
            used_default,
        } => EssentialStateVar::new_with_value(value, used_default),
    };

    // log_debug!("New essential data for {} {:?} {:?}", component_name, origin, essential_state);

    comp_essential_data.insert(origin.clone(), essential_state);

    &comp_essential_data.get(&origin).unwrap()
}
